[{"/Users/joncook/nodeproj/react-node/src/index.js":"1","/Users/joncook/nodeproj/react-node/src/game.js":"2","/Users/joncook/nodeproj/react-node/src/init.js":"3","/Users/joncook/nodeproj/react-node/src/action.js":"4","/Users/joncook/nodeproj/react-node/src/newname.js":"5","/Users/joncook/nodeproj/react-node/src/size.js":"6","/Users/joncook/nodeproj/react-node/src/message.js":"7","/Users/joncook/nodeproj/react-node/src/util.js":"8","/Users/joncook/nodeproj/react-node/src/name.js":"9","/Users/joncook/nodeproj/react-node/src/param.js":"10","/Users/joncook/nodeproj/react-node/src/paramDownClues.js":"11","/Users/joncook/nodeproj/react-node/src/paramAcrossClues.js":"12","/Users/joncook/nodeproj/react-node/src/paramBoard.js":"13","/Users/joncook/nodeproj/react-node/src/msg.js":"14","/Users/joncook/nodeproj/react-node/src/cell.js":"15","/Users/joncook/nodeproj/react-node/src/msgMgr.js":"16","/Users/joncook/nodeproj/react-node/src/paramCell.js":"17"},{"size":417,"mtime":1609805037000,"results":"18","hashOfConfig":"19"},{"size":33908,"mtime":1610284652000,"results":"20","hashOfConfig":"19"},{"size":2365,"mtime":1610284659000,"results":"21","hashOfConfig":"19"},{"size":1646,"mtime":1609850488000,"results":"22","hashOfConfig":"19"},{"size":732,"mtime":1609848268000,"results":"23","hashOfConfig":"19"},{"size":1247,"mtime":1609851359000,"results":"24","hashOfConfig":"19"},{"size":1167,"mtime":1609848818000,"results":"25","hashOfConfig":"19"},{"size":12038,"mtime":1610283127000,"results":"26","hashOfConfig":"19"},{"size":1223,"mtime":1609938744000,"results":"27","hashOfConfig":"19"},{"size":2035,"mtime":1610227873000,"results":"28","hashOfConfig":"19"},{"size":1234,"mtime":1610111408000,"results":"29","hashOfConfig":"19"},{"size":1260,"mtime":1610111400000,"results":"30","hashOfConfig":"19"},{"size":1432,"mtime":1610284659000,"results":"31","hashOfConfig":"19"},{"size":305,"mtime":1609596190000,"results":"32","hashOfConfig":"19"},{"size":886,"mtime":1610198472000,"results":"33","hashOfConfig":"19"},{"size":1002,"mtime":1609764965000,"results":"34","hashOfConfig":"19"},{"size":3682,"mtime":1610227886000,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"zl6ijb",{"filePath":"39","messages":"40","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"38"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"/Users/joncook/nodeproj/react-node/src/index.js",[],["72","73"],"/Users/joncook/nodeproj/react-node/src/game.js",["74"],"import React from 'react';\nimport Init from './init';\nimport Message from './message';\nimport Param from './param';\n\nimport Cell from './cell';\nimport MsgMgr from './msgMgr';\n\nimport * as Util from './util';\n\nclass Game extends React.Component {\n  constructor(props) {   \n    super(props);\n    console.log('Game : constructor : enter');\n\n    // enables a child to call onChangeXXXX with the selected value\n\n    // init\n    this.onChangeAction = this.onChangeAction.bind(this);\n    this.onChangeName = this.onChangeName.bind(this);\n    this.onChangeNewName = this.onChangeNewName.bind(this);\n    this.onChangeSize = this.onChangeSize.bind(this);\n    // message\n    this.onClickMessageClose = this.onClickMessageClose.bind(this);\n    // param\n    this.onClickParamCell = this.onClickParamCell.bind(this);\n    this.onKeyUpParamAcrossTextarea = this.onKeyUpParamAcrossTextarea.bind(this);\n    this.onKeyUpParamDownTextarea = this.onKeyUpParamDownTextarea.bind(this);\n    // play\n\n    // message manager\n    this.msgMgr = new MsgMgr();\n\n    this.state = {\n      updateTimestamp: '',\n      existingNames: null,\n      action: '',\n      msg: null,\n      name: '',\n      size: '',\n\n      // key : y.x   value : Cell\n      cellMap: null,\n\n      horizClues: '',  \n      vertClues: '',\n\n    };\n  }\n\n  componentDidMount() {\n    console.log('Game : componentDidMount : enter');\n    this.storeGetNames();\n  }\n\n  componentDidUpdate() {\n    console.log('Game : componentDidUpdate : enter');\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('Game : shouldComponentUpdate : enter');\n    return this.state.updateTimestamp != nextState.updateTimestamp;\n  }\n\n  // on methods\n  // CAN CHANGE STATE\n\n  onChangeAction(newAction) {\n\n    console.log('Game : START : -------------------------------------------->');\n    console.log('Game : START : onChangeAction ----> '+newAction+' --------->');\n    console.log('Game : START : -------------------------------------------->');\n\n    // set state since render needed\n    this.setState({ action: newAction });    \n  }\n  \n  onChangeName(newName) {\n\n    console.log('Game : START : -------------------------------------------->');\n    console.log('Game : START : onChangeName ----> '+newName+' --------->');\n    console.log('Game : START : -------------------------------------------->');\n\n    console.log('Game : onChangeName : enter : newName : ...'+newName+'...');\n    //   \n    let action = this.state.action;\n    if (action === Util.ACTION_DELETE) {\n      this.setState({ loading:true, name: newName });   \n      this.storeDelete(newName);\n\n    } else {\n      // other actions here\n\n    }\n\n  }\n\n  onChangeNewName(newName) {\n\n    console.log('Game : START : -------------------------------------------->');\n    console.log('Game : START : onChangeNewName ----> '+newName+' --------->');\n    console.log('Game : START : -------------------------------------------->');\n\n    let action = this.state.action;\n    if (action === Util.ACTION_CREATE) {\n      this.setState({ name: newName }); \n      if (Util.isExample(newName)) {\n        this.setupNew(0);\n      } \n    } else {\n      console.log(\"logic error : in onChangeNewName but action is not CREATE\");\n    }\n  }\n\n  onChangeSize(newSize) {\n\n    console.log('Game : START : -------------------------------------------->');\n    console.log('Game : START : onChangeSize ----> '+newSize+' --------->');\n    console.log('Game : START : -------------------------------------------->');  \n\n    let action = this.state.action;\n    if (action === Util.ACTION_CREATE) {\n\n      this.setupNew(newSize);\n\n    } else {\n      console.log(\"logic error : in onChangeSize but action is not CREATE\");\n    }\n  }\n\n  onClickMessageClose() {\n    console.log('Game : START : -------------------------------------------->');\n    console.log('Game : START : onClickMessageClose ------------------------>');\n    console.log('Game : START : -------------------------------------------->');  \n\n    this.msgMgr.clear(); \n\n    let name = this.state.name;\n    let action = this.state.action;\n    let existingNames = this.state.existingNames;\n\n    if (action === Util.ACTION_CREATE) {\n      if (!Util.isValidName(name) || Util.isDuplicateName(existingNames, name)) {\n        // force user to choose \"Size\" again\n        this.setState( { selectedAction: Util.ACTION_TITLE, \n          selectedSize: Util.SIZE_TITLE, msg: null} );  \n      } else {\n        \n        this.setState( { msg: null});\n\n      }\n    } else if (action === Util.ACTION_DELETE) {\n      this.storeGetNames();\n\n    } else {\n\n    }\n  }\n\n  onClickParamCell(id) {\n\n    console.log('Game : START : -------------------------------------------->');\n    console.log('Game : START : onClickParamCell ----> '+id+'------------->');\n    console.log('Game : START : -------------------------------------------->');  \n\n    let cellMap = this.toggleParamCell(id);\n\n    this.setState({ loading:true, cellMap: cellMap});\n\n    this.saveInUpdate();\n\n  }\n\n  onKeyUpParamAcrossTextarea(value) {\n    console.log('Game : START : -------------------------------------------->');\n    console.log('Game : START : onKeyUpParamAcrossTextarea ----------------------->');\n    console.log('Game : START : -------------------------------------------->');  \n\n    let atext = Util.convertCluesRomanDash(value);\n    atext = Util.convertCluesDash(atext);\n\n    this.setState({ loading:true, horizClues: atext });\n\n    this.saveInUpdate();\n\n  }\n\n  onKeyUpParamDownTextarea(value) {\n    console.log('Game : START : -------------------------------------------->');\n    console.log('Game : START : onKeyUpParamDownTextarea ----------------------->');\n    console.log('Game : START : -------------------------------------------->');  \n\n    let dtext = Util.convertCluesRomanDash(value);\n    dtext = Util.convertCluesDash(dtext);\n\n    this.setState({ loading:true, vertClues: dtext });\n\n    this.saveInUpdate();\n\n  }\n\n  // store methods\n  // DO NOT CHANGE STATE HERE\n\n  storeGet(name) {\n    console.log('Game : storeGet : enter : name : '+name);\n  \n    fetch('/cwords/name/'+name)\n    .then(\n      response => {\n        return response.json();\n      }\n    )\n    .then(\n      data => {\n        console.log('Game : storeGet : fetch : data : ...'+JSON.stringify(data)+'...');\n        let cwObj = JSON.parse(data.contents)\n        this.resultGet(cwObj, true, name);\n      }\n    )\n    .catch(\n      err => {\n        console.log('Game : storeGet : catch : err : ...'+JSON.stringify(err)+'...');\n        this.resultGet(null, false, name);\n      }\n    ) \n  }\n  \n  storeDelete(name) {\n    console.log('Game : storeDelete : enter : name : '+name);\n  \n    fetch('/cwords/name/'+name, {\n      method: 'DELETE',\n    })\n    .then(\n      response => {\n        return response.json();\n      }\n    )\n    .then(\n      data => {\n        console.log('Game : storeDelete : fetch : data = ...'+JSON.stringify(data)+'...');\n        this.resultDelete(true, name);\n      }\n    )\n    .catch(\n      err => {\n        console.log('Game : storeDelete : catch : err = ...'+JSON.stringify(err)+'...');\n        this.resultDelete(false, name);\n      }\n    ) \n  }\n\n  storeSave(cwObj) {\n    console.log('Game : storeSave : enter');\n  \n    // for play and update - assume the cword exists\n    // for other cases, (new, new-example, import) check first\n\n    let action = this.state.action;\n\n    if (action === Util.ACTION_PLAY || action === Util.ACTION_UPDATE) {\n      this.storeUpdate(cwObj);\n    } else {\n  \n      fetch('/cwords')\n      .then(\n        response => {\n          return response.json();\n        }\n      )\n      .then(\n        data => {\n          console.log('Game : storeSave : fetch : data : ...'+JSON.stringify(data)+'...');\n          let names = [];\n          for (let i=0; i<data.length; i++) {\n            let row = data[i];\n            let name = row.name;\n            names.push(name);\n          }\n          console.log('Game : storeSave : fetch : names = ...'+JSON.stringify(names)+'...');\n          if (names.includes(cwObj.name)) {\n            this.storeUpdate(cwObj);\n          } else {\n            this.storeInsert(cwObj);\n          }\n        }\n      )\n      .catch(\n        err => {\n          console.log('Game : storeSave : catch : err : ...'+JSON.stringify(err)+'...');\n          this.resultSave(false);\n        }\n      ) \n    }  \n  }\n\n  storeInsert(cwObj) {\n    console.log('Game : storeInsert : enter');\n  \n    fetch('/cwords', {\n      method: 'POST', \n      headers: {\n       'Content-type': 'application/json; charset=UTF-8' \n      },\n      body: JSON.stringify(cwObj)  \n     })\n    .then(\n      response => {\n        return response.json();\n      }\n    )\n    .then(\n      data => {\n        console.log('Game : storeInsert : fetch : data : ...'+JSON.stringify(data)+'...');\n        this.resultSave(true);\n      }\n    )\n    .catch(\n      err => {\n        console.log('Game : storeInsert : catch : err : ...'+JSON.stringify(err)+'...');\n        this.resultSave(false);\n      }\n    )  \n  }\n  \n  storeUpdate(cwObj) {\n    console.log('Game : storeUpdate : enter');\n  \n    fetch('/cwords/name/'+cwObj.name, {\n      method: 'PUT', \n      headers: {\n       'Content-type': 'application/json; charset=UTF-8' \n      },\n      body: JSON.stringify(cwObj)  \n     })\n    .then(\n      response => {\n        return response.json();\n      }\n    )\n    .then(\n      data => {\n        console.log('Game : storeUpdate : fetch : data : ...'+JSON.stringify(data)+'...');\n        this.resultSave(true);\n      }\n    )\n    .catch(\n      err => {\n        console.log('Game : storeUpdate : catch : err = ...'+JSON.stringify(err)+'...');\n        this.resultSave(false);\n      }\n    )  \n  }\n  \n  storeGetNames() {\n    console.log('Game : storeGetNames : enter');\n    fetch('/cwords')\n      .then(\n        response => {\n          return response.json();\n        }\n      )\n      .then(\n        data => {\n          console.log('Game : storeGetNames : fetch : data : ...'+JSON.stringify(data)+'...');\n  \n          let names = [];\n          for (let i=0; i<data.length; i++) {\n            let row = data[i];\n            let name = row.name;\n            names.push(name);\n          }\n          this.resultGetNames(true, names);\n          \n        }\n      )\n      .catch(\n        err => {\n          console.log('Game : storeGetNames : catch : err : ...'+JSON.stringify(err)+'...');\n          this.msgMgr.addError('Get crossword names failed');\n\n          this.resultGetNames(false, []);\n\n        }\n      )\n  }\n\n  // result methods, called:\n  // - after store methods \n  // - after build grid/clues methods\n  // - set the updateTimestamp here, which forces re-render\n  // CAN CHANGE STATE  \n\n  resultGetNames(ok, names) {\n    console.log('Game : resultGetNames : enter');\n    if (!ok) {\n      this.msgMgr.addError('Failed to get names.');\n    } \n\n    let msg = this.msgMgr.getMsg();\n    this.setState( { existingNames: names, \n      name: '', action: '', size: '',\n      msg: msg , updateTimestamp: Util.newDate()} );\n\n  }\n\n  resultSave(ok) {\n    console.log('Game : resultSave : enter');\n    let action = this.state.action;\n    if (action === Util.ACTION_IMPORT) {\n      // resultSaveImport(ok);\n    } else if (action === Util.ACTION_PLAY) {\n      // resultSavePlay(ok);\n    } else if (action === Util.ACTION_CREATE) {\n      this.resultSaveCreate(ok);\n    } else if (action === Util.ACTION_UPDATE) {\n      // resultSaveUpdate(ok);\n    }\n  }\n\n  resultSaveCreate(ok) {\n    console.log('Game : resultSaveCreate : enter');\n    let action = this.state.action;\n\n    if (!ok) {\n      this.msgMgr.addError('Failed to save.');\n    } else {\n      let name = this.state.name;\n\n      if (action === Util.ACTION_CREATE) {\n        if (Util.isExample(name)) {\n          this.msgMgr.addInfo('Created example : '+name+'.');\n        } else {\n          this.msgMgr.addInfo('Created : '+name+', now set blanks and clues');\n        }\n      } else {\n        // save message\n        // showConfirmMessage('Updated at '+date1()+\", Validate ?\");\n        this.msgMgr.addInfo('Updated : '+name+' at '+Util.date1() );\n      } \n      \n \n    }\n    let msg = this.msgMgr.getMsg();\n\n    this.setState( {\n      msg: msg , updateTimestamp: Util.newDate()} );\n\n  }\n\n  // note: not used yet\n  resultGet(cwObj, ok, name) {\n    console.log('Game : resultGet : enter');\n    if (!ok) {\n      this.msgMgr.addError('Failed to get crossword : '+name);\n\n    } else {\n\n      // let maxAcross = 1 * cwObj.maxAcross;\n      // console.log('maxAcross : ['+maxAcross+']');\n      // let maxDown = 1 * cwObj.maxDown;\n      // console.log('maxDown : ['+maxDown+']');\n\n      let size = Util.size(cwObj.maxAcross, cwObj.maxDown);\n\n      let blanks = cwObj.blanks;\n      console.log('blanks : ['+blanks+']');\n      let horizClues = cwObj.horizClues;\n      horizClues = Util.removeNewLines(horizClues); \n      console.log('horizClues : ['+horizClues+']');\n      let vertClues = cwObj.vertClues;\n      vertClues = Util.removeNewLines(vertClues); \n      console.log('vertClues : ['+vertClues+']');  \n      let cellValues = cwObj.cellValues;\n      console.log('cellValues : ['+cellValues+']'); \n      // this.setState( { name: name, maxAcross: maxAcross, maxDown: maxDown, blanks: blanks,\n      // horizClues: horizClues, vertClues: vertClues, cellValues: cellValues} );\n\n      this.setState( { name: name, size: size, blanks: blanks,\n        horizClues: horizClues, vertClues: vertClues, cellValues: cellValues,\n        updateTimestamp: Util.newDate()} );\n  \n    }\n  \n  }\n\n  resultDelete(deletedOK, name) {\n    console.log('Game : resultDelete : enter');\n    if (!deletedOK) {\n      this.msgMgr.addError('Failed to delete crossword : '+name);\n    } else {\n      this.msgMgr.addInfo('Deleted crossword : '+name);\n    }\n    let msg = this.msgMgr.getMsg();\n    // set state since new render needed\n    this.setState( {msg : msg, updateTimestamp: Util.newDate()} );\n  }\n\n  resultInitCellMap() {\n    console.log('Game : resultInitCellMap : enter');\n\n    let msg = this.msgMgr.getMsg();\n    if (msg!= null) {\n        this.setState( {msg : msg, updateTimestamp: Util.newDate()} );\n    }\n\n  }\n\n  // render methods\n  // NEVER CHANGE STATE HERE\n \n  renderCreate() {\n    // chose create, show name, size\n    console.log('Game : renderCreate : enter');\n    console.log('Game : renderCreate : state : '+JSON.stringify(this.state));\n    return (\n      <div className=\"game\">   \n        <Init \n          action={ this.state.action}\n          selectedAction={Util.ACTION_CREATE}\n          name={ this.state.name}\n          selectedName={Util.NAME_TITLE}\n          size={ this.state.size}\n          selectedSize={ Util.SIZE_TITLE }\n          onChangeAction={ this.onChangeAction }\n          onChangeName={ this.onChangeName }\n          onChangeNewName={ this.onChangeNewName }\n          onChangeSize={ this.onChangeSize }\n        /> \n        <Message         \n          msg={ this.state.msg }\n          onClick={ this.onClickMessageClose }\n        />       \n      </div>\n    );\n  }\n\n  renderCreateWithName() {\n    // chose create, entered name, get size\n    console.log('Game : renderCreateWithName : enter');\n    console.log('Game : renderCreateWithName : state : '+JSON.stringify(this.state));\n    return (\n      <div className=\"game\">   \n        <Init \n          action={ this.state.action}\n          selectedAction={Util.ACTION_CREATE}\n          name={ this.state.name}\n          selectedName={this.state.name}\n          size={ this.state.size}\n          selectedSize={ Util.SIZE_TITLE }\n          onChangeAction={ this.onChangeAction }\n          onChangeName={ this.onChangeName }\n          onChangeNewName={ this.onChangeNewName }\n          onChangeSize={ this.onChangeSize }\n        /> \n        <Message         \n          msg={ this.state.msg }\n          onClick={ this.onClickMessageClose }\n        />       \n      </div>\n    );\n  }\n\n  renderMessage() {\n    console.log('Game : renderMessage : enter');\n    console.log('Game : renderMessage : state : '+JSON.stringify(this.state));\n    return (\n      <div className=\"game\"> \n        <Message         \n          msg={ this.state.msg }\n          onClick={ this.onClickMessageClose }\n        />\n      </div>\n    );\n  }\n\n  renderSetupNew() {\n    // chose create, entered name, chose size\n    console.log('Game : renderSetupNew : enter');\n    console.log('Game : renderSetupNew : state : '+JSON.stringify(this.state));\n\n    let cells = {};\n    let cellMap = this.state.cellMap;\n    if (cellMap != null && cellMap.size > 0) {\n      cells = Util.mapToObject(cellMap);\n    }\n\n    console.log('Game : renderSetupNew : cells : '+JSON.stringify(cells));\n\n    return (\n      <div className=\"game\"> \n        <Init \n          action=''\n          selectedAction={ Util.ACTION_TITLE }\n          selectedSize={ this.state.selectedSize }\n          existingNames={ this.state.existingNames }\n          onChangeAction={ this.onChangeAction }\n        />\n        <Message         \n          msg={ this.state.msg }\n          onClick={ this.onClickMessageClose }\n        /> \n        <Param\n          name={ this.state.name}\n          size={ this.state.size}\n          cells={ cells }\n          horizClues={ this.state.horizClues }\n          vertClues={ this.state.vertClues }\n          onClickParamCell={ this.onClickParamCell }\n          onKeyUpParamAcrossTextarea={ this.onKeyUpParamAcrossTextarea }\n          onKeyUpParamDownTextarea={ this.onKeyUpParamDownTextarea }\n        />\n      </div>\n    );\n  }\n\n  renderSetupNewExample() {\n    // chose create, entered example name, chose size\n    console.log('Game : renderSetupNewExample : enter');\n    console.log('Game : renderSetupNewExample : state : '+JSON.stringify(this.state));\n\n    return (\n      <div className=\"game\">   \n        <Init \n          action=''\n          selectedAction={ Util.ACTION_TITLE }\n          existingNames={ this.state.existingNames }\n          onChangeAction={ this.onChangeAction }\n        />   \n        <Message         \n          msg={ this.state.msg }\n          onClick={ this.onClickMessageClose }\n        />    \n      </div>\n    );\n  }\n\n  renderDelete() {\n    // chose delete\n    console.log('Game : renderDelete : enter');\n    console.log('Game : renderDelete : state : '+JSON.stringify(this.state));\n    return (\n      <div className=\"game\"> \n        <Init \n          action={ this.state.action}\n          selectedAction={Util.ACTION_DELETE}\n          name={ this.state.name}\n          existingNames={ this.state.existingNames }\n          onChangeName={ this.onChangeName }\n        /> \n        <Message         \n          msg={ this.state.msg }\n          onClick={ this.onClickMessageClose }\n        />   \n      </div>\n    );\n  }\n\n  renderDeleteMessage() {\n    // chose delete\n    console.log('Game : renderDeleteMessage : enter');\n    console.log('Game : renderDeleteMessage : state : '+JSON.stringify(this.state));\n    return (\n      <div className=\"game\"> \n        <Init \n          action={ this.state.action}\n          selectedAction={Util.ACTION_TITLE}\n          name={ this.state.name}\n          existingNames={ this.state.existingNames }\n          onChangeName={ this.onChangeName }\n        /> \n        <Message         \n          msg={ this.state.msg }\n          onClick={ this.onClickMessageClose }\n        />   \n      </div>\n    );\n  }\n\n  renderInit() {\n    console.log('Game : renderInit : enter');\n    console.log('Game : renderInit : state : '+JSON.stringify(this.state));\n    return (\n      <div className=\"game\">   \n        <Init \n          existingNames={ this.state.existingNames }\n          onChangeAction={ this.onChangeAction }\n        />         \n      </div>\n    );\n  }\n\n  render() {\n    \n    console.log('Game : render : enter');\n    console.log('Game : render : state : '+JSON.stringify(this.state));\n    let action = this.state.action;\n    let name = this.state.name;\n    let size = this.state.size;\n    let loading = this.state.loading;\n    let msg = this.state.msg;\n\n    if (loading) {\n      if (msg) {\n        return this.renderMessage();\n      } else {\n        return (\n          <p>Loading</p>\n        )\n      }\n    } else {\n      if (action === Util.ACTION_CREATE) {\n        if (name === '') {\n          // name + size to be chosen\n          return this.renderCreate();\n        } else {\n          if (Util.isExample(name)) {\n            // example name has been chosen, cword saved, show message\n            return this.renderSetupNewExample();\n          } else {\n            if (size === '') {\n              // name has been chosen, size to be chosen\n              return this.renderCreateWithName();\n            } else {\n              // name, size has been chosen, cword saved, show message and params\n              return this.renderSetupNew();\n            }\n          }\n        }\n      // } else if (this.state.action === Util.ACTION_PLAY) {\n\n      // } else if (this.state.action === Util.ACTION_UPDATE) {\n\n      // } else if (this.state.action === Util.ACTION_EXPORT) {\n\n      // } else if (this.state.action === Util.ACTION_IMPORT) {\n\n      } else if (action === Util.ACTION_DELETE) {\n        if (name === '') {\n          return this.renderDelete();\n        } else {\n          return this.renderDeleteMessage() \n        }\n      } else if (this.state.action === Util.ACTION_CLEAR) {\n        return this.renderInit();   \n      } else {\n        return this.renderInit();        \n      }   \n    }\n  }\n\n  // util methods\n  // NEVER CHANGE STATE HERE\n  // only read state then either:\n  //  - return values\n  //  - call other methods\n\n  toggleParamCell(id) {\n    console.log('Game : toggleParamCell : enter : id : '+id);\n\n    // get the current state of cells\n    let cellMap = this.state.cellMap;\n\n    // toggle the cell in cellMap : key is y.x\n\n    if (!cellMap.has(id)) {\n      // its a blank so make not a blank\n      let y = Util.row(id);\n      let x = Util.column(id);\n      let cell = new Cell(y, x);\n      cellMap.set(id, cell);\n    } else {\n      // its not a blank so make a blank \n      cellMap.delete(id);\n    }\n\n    // let blanks = this.getBlanks(blankMap);\n    // console.log('blanks : ['+blanks+']');\n    return cellMap;\n\n  }\n\n  setupNew(size) {\n    console.log('Game : setupNew : enter : size : '+size);\n    let name = this.state.name;\n\n    let existingNames = this.state.existingNames;\n\n    if (!Util.isValidName(name)) {\n      this.msgMgr.addError('Invalid name');\n      this.setState({ \n        msg : this.msgMgr.getMsg() \n      });\n\n    } else if (Util.isDuplicateName(existingNames, name)) {\n      this.msgMgr.addError('Duplicate name');\n      this.setState({ \n        msg : this.msgMgr.getMsg() \n      });\n    } else {\n\n      this.setState({ loading : true, size: size });\n\n      let cwObj = Util.EXAMPLE_MAP.get(name);\n      if (cwObj != null) {    \n        console.log('Game : setupNew : example case');\n\n        this.saveCwordObject(cwObj);\n      } else {\n        console.log('Game : setupNew : non example case');\n\n        let cword = {};\n        cword.name = this.state.name;\n        cword.maxAcross = Util.maxAcross(size);\n        cword.maxDown = Util.maxDown(size);\n\n        // all empty on creation\n        cword.blanks = '';\n        cword.horizClues = '';\n        cword.vertClues = '';\n        cword.cellValues = '';\n\n        this.saveCwordObject(cword);\n      }\n    }\n  }\n\n  makeCwObject() {\n    let cword = {};\n    let size = this.state.size;\n\n    cword.name = this.state.name;\n    cword.maxAcross = Util.maxAcross(size);\n    cword.maxDown = Util.maxDown(size);\n\n    cword.blanks = this.getBlanks();\n    cword.horizClues = this.horizClues;\n    cword.vertClues = this.vertClues;\n    cword.cellValues = this.getCellValues();\n\n    return cword;\n  }\n\n  getBlanks() {\n    let size = this.state.size;\n    let maxAcross = Util.maxAcross(size);\n    let maxDown = Util.maxAcross(size);\n    let cellMap = this.state.cellMap;\n    let blanks = '';\n    let lines = '';\n    for (let y=1; y<=maxDown; y++) {\n      let line = '';\n      for (let x=1; x<=maxAcross; x++) {\n        let cellKey = Util.cellKey(y, x);\n        if (!cellMap.has(cellKey)) {\n          if (line === '') {\n            line = ''+x;\n          } else {\n            line += ','+x;\n          }\n        }\n      }\n      if (line.length > 0) {\n        line = y+' '+line;\n        lines += line+';';\n      }\n    }\n    lines = lines.trim();\n    blanks = lines;\n    return blanks;\n  }\n\n  getCellValues() {\n    let size = this.state.size;\n    let maxAcross = Util.maxAcross(size);\n    let maxDown = Util.maxAcross(size);\n    let cellMap = this.state.cellMap;\n\n    let cellValues = {};\n    for (let y=1; y<=maxDown; y++) {\n      for (let x=1; x<=maxAcross; x++) {\n        var cellKey = Util.cellKey(y,x);\n        console.log('cell->toObject .... cellKey : ['+cellKey+']');\n        var cell = cellMap.get(cellKey);\n        if (cell != null) {\n          let val = cell.value;\n          if (val != null && val.length > 0) {\n            cellValues[cellKey] = val;\n            console.log('............ cell->toObject : ['+cellKey+'] : ['+val+']');\n          }        \n        }\n      }\n    }\n    return cellValues;\n  }\n\n  saveInUpdate() {\n    console.log('Game : saveInUpdate : enter');\n\n    // save the crossword\n    let cwObj = this.makeCwObject();\n  \n    this.saveCwordObject(cwObj);\n\n  }\n\n  saveCwordObject(cwObj) {\n    console.log('Game : saveCwordObject : enter');\n\n    let maxAcross = cwObj.maxAcross;\n    let maxDown = cwObj.maxDown;\n    let size = Util.size(maxAcross, maxDown);\n\n    let blanks = cwObj.blanks;\n    let cellValues = cwObj.cellValues;\n    let cellMap = this.setupCellMap(maxAcross, maxDown, blanks, cellValues);\n\n    let horizClues = cwObj.horizClues;\n    let vertClues = cwObj.vertClues;\n\n    this.setState(\n      { size: size, cellMap: cellMap, horizClues: horizClues, vertClues: vertClues}\n    );\n  \n    this.storeSave(cwObj);\n\n  }\n\n  setupCellMap(maxAcross, maxDown, blanks, cellValues) {\n    console.log('Game : setupCellMap : enter');\n    let cellMap = new Map();\n\n    // blank cells \n    let blankMap = this.setupBlankMap(maxAcross, maxDown, blanks);\n\n    // values\n    let valueMap = this.setupValueMap(maxAcross, maxDown, cellValues);\n\n    // setup cells\n    for (let y=1; y<=maxDown; y++) {\n      for (let x=1; x<=maxAcross; x++) {\n        let cellKey = Util.cellKey(y,x);\n        if (!blankMap.has(cellKey)) {  \n          let cell = new Cell(y,x);\n          cellMap.set(cellKey, cell);\n          console.log('Setup cell at '+cellKey);\n          if (valueMap.has(cellKey)) {\n            let val = valueMap.get(cellKey);\n            cell.value = val;\n            console.log('........ cell value to '+val+' at '+cellKey);\n          }\n        }\n      }\n    }\n\n    console.log(\"cells : \"+JSON.stringify(Util.mapToObject(cellMap)));\n\n    return cellMap;\n  }\n\n  setupValueMap(maxAcross, maxDown,cellValues) {\n    let valueMap = new Map();\n    for (let y=1; y<=maxDown; y++) {\n      for (let x=1; x<=maxAcross; x++) {\n        var cellKey = y+'.'+x;\n        var val = cellValues[cellKey];\n        if (val != null && val.length > 0) {\n          if (!valueMap.has(cellKey)) {\n            valueMap.set(cellKey, val);\n            console.log('............ cell->toMap : ['+cellKey+'] : ['+val+']');\n          } \n        }\n      }\n    }\n\n    console.log(\"values : \"+JSON.stringify(Util.mapToObject(valueMap)));\n    return valueMap;\n  }\n\n  setupBlankMap(maxAcross, maxDown,blanks) {\n    let blankMap = new Map();\n  \n    // setup blanks\n    let blankLines = blanks.split(';');\n    for (let i = 0; i < blankLines.length; i++) {\n      let line = blankLines[i]; \n      line = line.trim();\n      if (line.length === 0) {\n        continue;\n      }\n      console.log('BlankLine#'+(i+1)+' ['+line+']');\n      let lineParts = line.split(' ');\n      if (lineParts.length !== 2) {\n        console.log(\"Bad # parts, need 2, but have : \"+lineParts.length);\n        this.msgMgr.addWarning('Bad # parts, need 2, but have : '+lineParts.length);\n      }\n      let yVal = lineParts[0];\n      if (yVal < 1) {\n        this.msgMgr.addWarning('getBlankMap : y is < 1 : '+yVal);\n      }\n      if (yVal > maxDown) {\n        this.msgMgr.addWarning('getBlankMap : y is > maxDown : '+yVal);\n      }\n      let xVals = lineParts[1];\n      let xParts = xVals.split(',');\n      for (let j = 0; j < xParts.length; j++) {\n        let xVal = xParts[j];\n        if (xVal < 1) {\n          this.msgMgr.addWarning('getBlankMap : x is < 1 : '+xVal);\n        }\n        if (xVal > maxAcross) {\n          this.msgMgr.addWarning('getBlankMap : x is > maxAcross : '+xVal);\n        }\n        let key = Util.cellKey(yVal,xVal);\n\n        blankMap.set(key, key);\n        console.log('Setup blank at '+key);\n      }\n    }\n\n    console.log(\"blanks : \"+JSON.stringify(Util.mapToObject(blankMap)));\n\n    return blankMap;\n  }\n\n//   // initialize cell map\n//   initCellMap() {\n\n//     let name = this.state.name;\n//     let size = this.state.size;\n//     let maxAcross = Util.maxAcross(size);\n//     let maxDown = Util.maxDown(size);\n\n//     if (!Util.isValidName(name)) {\n//       this.msgMgr.addError('Invalid crossword name.|Crossword name must have 3-80 characters and not start with --.');\n//     }\n  \n//     if (!Util.isAllowedAcross(maxAcross)) {\n//       this.msgMgr.addWarn('Invalid maxAcross : '+maxAcross);\n//     }\n  \n//     if (!Util.isAllowedDown(maxDown)) {\n//       this.msgMgr.addWarn('Invalid maxDown : '+maxDown);\n//     }\n    \n//     let cellMap = new Map();\n  \n//     // let clueMap = new Map();\n  \n//     // The Blank Cells \n//     let blankMap = this.getBlankMap();\n  \n//     // setup cells\n//     for (let y=1; y<=maxDown; y++) {\n//       for (let x=1; x<=maxAcross; x++) {\n//         let cellKey = x+'.'+y;\n//         if (!blankMap.has(cellKey)) {  \n//           let cell = new Cell(x,y);\n//           cellMap.set(cellKey, cell);\n//           console.log('Setup cell at '+cellKey);\n//         }\n//       }\n//     }\n//     console.log('Setup '+cellMap.size+' cells');\n  \n//     if (cellMap.size === 0) {\n//       this.msgMgr.addWarn('No valid cells');\n//     }\n  \n//     let avail = maxAcross * maxDown;\n//     let used = blankMap.size + cellMap.size;\n//     if (avail === used) {\n//       console.log('All used : avail='+avail+ ', used='+used);\n//     } else {\n//       // console.log('ERROR : All NOT used : avail='+avail+ ', used='+used);\n//       this.msgMgr.addWarn('Not all cells used in initCellMap. Available='+avail+ ', used='+used);\n//     }\n\n//     this.resultInitCellMap();\n\n//     return cellMap;\n//     // this.setState( { cellMap: cellMap });\n  \n//   }\n  \n//   // get blankMap from state.blanks\n//   getBlankMap() {\n//     console.log('Game : getBlankMap : enter');\n//     let blanks = this.state.blanks;\n//     let size = this.state.size;\n//     let maxAcross = Util.maxAcross(size);\n//     let maxDown = Util.maxDown(size);\n\n//     // let msg = null;\n\n//     // OLD : The Blank Cells : key = x.y  val = x.y \n//     // NEW : The Blank Cells : key = aa  val = aa \n//     let blankMap = new Map();\n  \n//     // this makes no sense on first call\n//     // if (blanks.length === 0) {\n//     //   this.msgMgr.addError('No blanks defined.|At least one blank must be defined.');\n//     // }\n  \n//     // setup blanks\n//     let blankLines = blanks.split(';');\n//     for (let i = 0; i < blankLines.length; i++) {\n//       let line = blankLines[i]; \n//       line = line.trim();\n//       if (line.length === 0) {\n//         continue;\n//       }\n//       console.log('BlankLine#'+(i+1)+' ['+line+']');\n//       let lineParts = line.split(' ');\n//       if (lineParts.length !== 2) {\n//         console.log(\"Bad # parts, need 2, but have : \"+lineParts.length);\n//         this.msgMgr.addWarning('Bad # parts, need 2, but have : '+lineParts.length);\n//       }\n//       let yVal = lineParts[0];\n//       if (yVal < 1) {\n//         this.msgMgr.addWarning('getBlankMap : y is < 1 : '+yVal);\n//       }\n//       if (yVal > maxDown) {\n//         this.msgMgr.addWarning('getBlankMap : y is > maxDown : '+yVal);\n//       }\n//       let xVals = lineParts[1];\n//       let xParts = xVals.split(',');\n//       for (let j = 0; j < xParts.length; j++) {\n//         let xVal = xParts[j];\n//         if (xVal < 1) {\n//           this.msgMgr.addWarning('getBlankMap : x is < 1 : '+xVal);\n//         }\n//         if (xVal > maxAcross) {\n//           this.msgMgr.addWarning('getBlankMap : x is > maxAcross : '+xVal);\n//         }\n//         // OLD let key = xVal+'.'+yVal;\n//         // NEW \n//         let key = Util.toCellId(yVal, xVal);\n\n//         blankMap.set(key, key);\n//         console.log('Setup blank at '+key);\n//       }\n//     }\n  \n//     console.log('Setup '+blankMap.size+' blanks');\n  \n//     // this makes no sense on first call\n//     // if (blankMap.size === 0) {\n//     //   this.msgMgr.addError('No blanks parsed.|Failed to make any blanks from BLANKS string.');\n//     // }\n  \n//     return blankMap;\n//   }\n\n//   // get valueMap from cellValues\n//   cellValuesToMap() {\n\n//     let cellMap = this.state.cellMap;\n//     let cellValues = this.state.cellValues;\n\n//     let size = this.state.size;\n//     let maxAcross = Util.maxAcross(size);\n//     let maxDown = Util.maxDown(size);\n\n//     let valueMap = new Map();\n//     for (let y=1; y<=maxDown; y++) {\n//       for (let x=1; x<=maxAcross; x++) {\n//         let cellKey = x+'.'+y;\n//         console.log('cell->toMap .... cellKey : ['+cellKey+']');\n//         let cell = cellMap.get(cellKey);\n//         if (cell != null) {\n//           let cellId = cell.toId();\n//           let val = cellValues[cellId];\n//           if (val != null && val.length > 0) {\n//             if (!valueMap.has(cellId)) {\n//               valueMap.set(cellId, val);\n//               console.log('............ cell->toMap : ['+cellId+'] : ['+val+']');\n//             } else {\n//               console.log('Dup value from CELL_VALUES for : ['+cellId+']');\n//             }\n//           }\n//         }\n//       }\n//     }\n//     return valueMap;\n//   }\n// }\n\n}\n\nexport default Game;\n","/Users/joncook/nodeproj/react-node/src/init.js",[],"/Users/joncook/nodeproj/react-node/src/action.js",[],"/Users/joncook/nodeproj/react-node/src/newname.js",[],"/Users/joncook/nodeproj/react-node/src/size.js",[],"/Users/joncook/nodeproj/react-node/src/message.js",[],"/Users/joncook/nodeproj/react-node/src/util.js",[],"/Users/joncook/nodeproj/react-node/src/name.js",[],"/Users/joncook/nodeproj/react-node/src/param.js",[],"/Users/joncook/nodeproj/react-node/src/paramDownClues.js",[],"/Users/joncook/nodeproj/react-node/src/paramAcrossClues.js",[],"/Users/joncook/nodeproj/react-node/src/paramBoard.js",[],"/Users/joncook/nodeproj/react-node/src/msg.js",[],"/Users/joncook/nodeproj/react-node/src/cell.js",[],"/Users/joncook/nodeproj/react-node/src/msgMgr.js",[],"/Users/joncook/nodeproj/react-node/src/paramCell.js",[],{"ruleId":"75","replacedBy":"76"},{"ruleId":"77","replacedBy":"78"},{"ruleId":"79","severity":1,"message":"80","line":62,"column":39,"nodeType":"81","messageId":"82","endLine":62,"endColumn":41},"no-native-reassign",["83"],"no-negated-in-lhs",["84"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","no-global-assign","no-unsafe-negation"]